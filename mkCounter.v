//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Fri Jun  3 17:32:02 BRT 2016
//
//
// Ports:
// Name                         I/O  size props
// read                           O     8 reg
// RDY_read                       O     1 const
// term                           O     8 reg
// RDY_term                       O     1 const
// readflag                       O     1 reg
// RDY_readflag                   O     1 const
// RDY_load                       O     1 const
// RDY_increment                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// load_newval                    I     8 reg
// EN_load                        I     1
// EN_increment                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCounter(CLK,
		 RST_N,

		 read,
		 RDY_read,

		 term,
		 RDY_term,

		 readflag,
		 RDY_readflag,

		 load_newval,
		 EN_load,
		 RDY_load,

		 EN_increment,
		 RDY_increment);
  input  CLK;
  input  RST_N;

  // value method read
  output [7 : 0] read;
  output RDY_read;

  // value method term
  output [7 : 0] term;
  output RDY_term;

  // value method readflag
  output readflag;
  output RDY_readflag;

  // action method load
  input  [7 : 0] load_newval;
  input  EN_load;
  output RDY_load;

  // action method increment
  input  EN_increment;
  output RDY_increment;

  // signals for module outputs
  wire [7 : 0] read, term;
  wire RDY_increment, RDY_load, RDY_read, RDY_readflag, RDY_term, readflag;

  // register flag
  reg flag;
  wire flag$D_IN, flag$EN;

  // register total
  reg [7 : 0] total;
  wire [7 : 0] total$D_IN;
  wire total$EN;

  // register value
  reg [7 : 0] value;
  wire [7 : 0] value$D_IN;
  wire value$EN;

  // remaining internal signals
  wire value_EQ_total___d3;

  // value method read
  assign read = value ;
  assign RDY_read = 1'd1 ;

  // value method term
  assign term = total ;
  assign RDY_term = 1'd1 ;

  // value method readflag
  assign readflag = flag ;
  assign RDY_readflag = 1'd1 ;

  // action method load
  assign RDY_load = 1'd1 ;

  // action method increment
  assign RDY_increment = 1'd1 ;

  // register flag
  assign flag$D_IN = 1'd1 ;
  assign flag$EN = EN_increment && value_EQ_total___d3 ;

  // register total
  assign total$D_IN = load_newval ;
  assign total$EN = EN_load ;

  // register value
  assign value$D_IN = value + 8'd1 ;
  assign value$EN = EN_increment && !value_EQ_total___d3 ;

  // remaining internal signals
  assign value_EQ_total___d3 = value == total ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        flag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	total <= `BSV_ASSIGNMENT_DELAY 8'd0;
	value <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (flag$EN) flag <= `BSV_ASSIGNMENT_DELAY flag$D_IN;
	if (total$EN) total <= `BSV_ASSIGNMENT_DELAY total$D_IN;
	if (value$EN) value <= `BSV_ASSIGNMENT_DELAY value$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    flag = 1'h0;
    total = 8'hAA;
    value = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCounter

